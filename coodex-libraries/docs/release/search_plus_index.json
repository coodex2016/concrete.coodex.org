{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction coodex libraries是一组小工具集，包含有 coodex-utilities coodex-utilities-servlet shared-cache shared-cache-jedis shared-cache-memcached coodex-mock-spec coodex-mock-impl coodex-billing coodex-renderer-freemarker 以上模块使用相同版本号发布,当前版本为0.5.0-SNAPSHOT，在本文档中，统一使用${coodex.libraries.version}代替，使用者可自行在pom.xml中定义此变量。 使用依赖管理的工程，可以在依赖管理中import构件清单模块: org.coodex coodex-bom ${coodex.libraries.version} pom import © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-10 09:24:41 "},"coodex-utilities/":{"url":"coodex-utilities/","title":"coodex-utilities","keywords":"","body":"coodex-utilities maven usage org.coodex coodex-utilities ${coodex.libraries.version} © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-10 09:25:03 "},"coodex-utilities/org.coodex.util.Common.html":{"url":"coodex-utilities/org.coodex.util.Common.html","title":"Common","keywords":"","body":"org.coodex.util.Common 一组通用方法和常量。 常量 PATH_SEPARATOR: 多个路径的分隔符，windows平台为;, linux平台为: FILE_SEPARATOR: 文件分隔符，windows平台为\\, linux平台为/ DEFAULT_DATE_FORMAT: 默认的日期格式，yyyy-MM-dd DEFAULT_TIME_FORMAT: 默认的时间格式， HH:mm:ss DEFAULT_DATETIME_FORMAT: 默认时间戳格式，yyyy-MM-dd HH:mm:ss SYSTEM_START_TIME: JVM启动的时间 PROCESSOR_COUNT: 处理器的个数 方法 arrayToSet(T[]): Set 将一个数组转为set. base16Encode 将byte数组按base16编码。 以[0x00 - 0xFF] 为例，各个接口使用效果如下： System.out.println(Common.base16Encode(bytes)); 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff System.out.println(Common.base16Encode(bytes,16/*每行16个字节*/,\" \"/*每行中列于列之间使用空格隔开*/)); 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff System.out.println(Common.base16Encode(bytes,line->line + 1/*每行显示数量为行数+1,行号从0开始*/,\" \"/*每行中列于列之间使用空格隔开*/)); 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff System.out.println(Common.base16Encode(bytes,16/*从下标为16的元素开始*/,8/*编码8个字节*/)); 1011121314151617 System.out.println(Common.base16Encode(bytes,16/*从下标为16的元素开始*/,8/*编码8个字节*/,4/*每行4列*/,\" \")); 10 11 12 13 14 15 16 17 System.out.println(Common.base16Encode(bytes,16/*从下标为16的元素开始*/,10/*编码10个字节*/, line->line+1, \" \")); 10 11 12 13 14 15 16 17 18 19 calendar 快捷构造Calendar的系列接口，参数从左到右，分别是年、月（从0起）、日、时、分、秒、毫秒 calendarToStr Calnedar转字符串，默认格式yyyy-MM-dd HH:mm:ss. copyStream 将一个InputStream拷贝到OutputStream，可限速 difference 求两个Set1-Set2的差集 getResource 在coodex.resource.path详见和classpath中查找指定资源 intersection 求两个Set的交集 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-08 13:23:48 "},"coodex-utilities/org.coodex.util.Singleton.html":{"url":"coodex-utilities/org.coodex.util.Singleton.html","title":"单例","keywords":"","body":"通用单例模式 org.coodex.util.Singleton 很多场景下，我们需要用到单例模式，大部分情况会采用以下方式管理单例 private static final A a = new A(); 或者懒加载模式 private static A a; private static A get(){ if(a == null){ synchronized(A.class){ if(a ==null){ a = new A(); } } } return a; } coodex-utilities简化了懒加载模式 private static final Singleton A_SINGLETON = Singleton.with(A::new); 使用时 A_SINGLETON.get(); 当然，这个例子不能说明什么，关键是，通过使用build模式，我们可以在代码中隔离掉构建的具体细节 org.coodex.util.SingletonMap SingletonMap按照键值对的方式管理单例的实例，每个键的值都维持一个单例，可用作缓存；提供了多个重载的get接口，方便单例对象的构建。对于同一个键，同一时刻最多维持一个实例。 创建SingletonMap private static final SingletonMap SINGLETON_MAP = SingletonMap.builder() // 默认的值构建function .function(String::valueOf) // 最大缓存时间，单位毫秒，{}) //map的构建器，默认用ConcurrentHashMap .mapSupplier(ConcurrentHashMap::new) // 不同的map对null作为键值的处理方式不同，为了适配多种map的实现，可以指定nullKey等同于哪个key .nullKey(Integer.MIN_VALUE) // 管理值对象生命周期的线程池 .scheduledExecutorService(ExecutorsHelper.newSingleThreadScheduledExecutor(\"test\")) .build(); builder的参数均有默认值，只有一个需要注意：function，如果不指定，则调用get接口时，需要明确的传入构建Function或者Supplier //nullKey System.out.println(SINGLETON_MAP.get(null)); //1秒后失效 System.out.println(SINGLETON_MAP.get(1,1000)); //使用非默认function来构建值，使用Function类似 System.out.println(SINGLETON_MAP.get(2,()->\"hello coodex.\")); // 因为2的值已存在，所以看到的还是hello coodex System.out.println(SINGLETON_MAP.get(2,()->\"can u see me?\")); // 使用非默认的deathListener System.out.println(SINGLETON_MAP.get(3,500,(i,s)->System.out.println(\"key: \" + i + \", value: \" + s ))); // 其他接口不再一一演示 -2147483648 1 hello coodex. hello coodex. 3 key: 3, value: 3 开启logging的debug，还可以看见以下信息： 2020-05-11 09:49:01.925 [test-1][org.coodex.util.SingletonMap.lambda$get$2(SingletonMap.java:130)] [DEBUG] 3 die. 2020-05-11 09:49:02.415 [test-1][org.coodex.util.SingletonMap.lambda$get$2(SingletonMap.java:130)] [DEBUG] 1 die. © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-10-12 08:48:12 "},"coodex-utilities/org.coodex.util.ResourceScanner.html":{"url":"coodex-utilities/org.coodex.util.ResourceScanner.html","title":"资源扫描器","keywords":"","body":"资源扫描器 基于约定大于配置的理念实现的一个用于扫描指定包下相关资源的工具类 系统变量coodex.resource.path用来指定外部文件系统扩展路径 usage ResourceScanner // 扫描到的资源怎么处理 .newBuilder((url, string) -> { try (InputStream inputStream = url.openStream()) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Common.copyStream(inputStream, byteArrayOutputStream); System.out.println(url.toString() + \" size: \" + byteArrayOutputStream.toByteArray().length); } catch (Throwable e) { e.printStackTrace(); } } ) // 根据资源名进行过滤，默认不过滤 // .filter(resourceName -> true) // 是否使用扩展路径，即-Dcoodex.resource.path指定的路径 .extraPath(true) .build() // 在某些包下扫描 .scan(\"org/**/id\",\"test\",\"i18n\"); © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-10 11:45:10 "},"coodex-utilities/SPI.html":{"url":"coodex-utilities/SPI.html","title":"SPI","keywords":"","body":"SPI - Service Provider Interfaces java 1.6起增加了SPI机制，定义好一个Provider Interface，然后在META-INF/services目录下建一个同名的文档，按行添加该接口的实现类，即可通过ServiceLoader获取所有的Provider实例，是OOAD设计原则中依赖反转思想的体现，让系统可扩展性更好。 java原生的SPI机制只能由jvm根据类来提供实例，按DI的理念来讲，我们不应该关注或者限定实例的提供方式，所以coodex设计了一个既兼容java SPI且扩展性更强的SPI机制。 org.coodex.util.ServiceLoader Map getAll() 获取所有此类型的实例，coodex SPI为实例增加了一个名称的属性，参考了javax.inject规范的name设计，在扩展和服务选择时可以更方便的操作 T get(Class) 根据一个类型获取服务实例 T get(String) 根据名称获取服务实例 T get() 获取实例，当存在多个服务实例时，可通过重载LazyServiceLoader的conflict系列方法来解决 T getDefault() 获取默认的服务实例。coodex SPI建议每个Loader都能提供一个默认的服务实例，减少使用复杂度 org.coodex.util.LazyServiceLoader coodex SPI的实现 usage 例如，我们有一个interface A private static final ServiceLoader A_SERVICE_LOADER = new ServiceLoaderImpl(){}; 扩展点 org.coodex.util.ServiceLoaderProvider coodex SPI机制相对java SPI来讲，支持多种ServiceLoader，需要增加你的Loader机制时，只需要实现一个ServiceLoaderProvider即可 已有的实现包括 org.coodex.util.JavaUtilServiceLoaderProvider coodex-utitlies中，基于java.util.ServiceLoader的Provider org.coodex.util.SpringServiceLoaderProvider 基于Spring的ServiceLoaderProvider，使用时放入JUS和spring容器即可 SelectableServiceLoader> 一个coodex SPI的扩展，可以根据参数来选择一个能够处理该参数的服务实例 假定有以下service public interface NumberSelectableService extends SelectableService{} 奇数是一个服务实例，偶数是一个实例 public class OddNumberSelectableService implements NumberSelectableService{ @Override public boolean accept(Integer param) { return param != null && param % 2 == 1; } } public class EvenNumberSelectableService implements NumberSelectableService{ @Override public boolean accept(Integer param) { return param != null && param % 2 == 0; } } 使用 private static final SelectableServiceLoader NUMBER_SERVICE_LOADER = new LazySelectableServiceLoader() { }; NUMBER_SERVICE_LOADER.select(0);// 获取到的是EvenNumberSelectableService的实例 NUMBER_SERVICE_LOADER.select(1);// 获取到的是OddNumberSelectableService的实例 SelectableServiceLoader是一种策略模式(wiki, 百度)的设计，非常理想的隔离了不同数据控制实现 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-10-12 17:32:23 "},"coodex-utilities/org.coodex.util.Profile.html":{"url":"coodex-utilities/org.coodex.util.Profile.html","title":"Profile","keywords":"","body":"Profile profile是一个key-value的模型。 主要接口 getInt(String)/ getInt(String, int) 从profile中获取指定key的整型值 getBool(String)/ getBool(String, boolean) 从profile中获取指定key的布尔值 getLong(String)/ getLong(String, long) 从profile中获取指定key的长整型值 getString(String)/ getString(String, String) 从profile中获取指定key的字符串值 getStrList(String)/ getStrList(String, String)/ getStrList(String, String, String[]) 从profile中获取指定key的字符串数组 usage // 根据指定资源名获取Profile实例，未指定类型时，将自动检索 Profile profile = Profile.get(\"profileName\"); // 多项资源合并为一个Profile，取值时，越靠前的优先级越高 Profile profile = Profile.get(\"a\", \"b\", \"c\"); Profile默认支持.properties，如果你的工程中引入了snakeyaml，则profile支持.yml|yaml文件 类似于spring.active.profiles，支持多环境差异化配置。 -Dcoodex.active.profiles=a1,a2,a3 则 Profile.get(\"profileName\") 时，相当于聚合了\"profileName-a1\",\"profileName-a2\",\"profileName-a3\",\"profileName\" 特别的：在org.coodex.spring中扩展了一个与spring.active.profiles一致的ActiveProfilesProvider，使用时将其放入SPI范围即可例如: -Dspring.active.profiles=dev 则Profile.get(\"app\")相当于聚合了app-dev和app 替换符 当某个键值引用其他资源的键值时，可使用替换符，格式为: ${refResource:key} 系统变量 org.coodex.util.Profile.reloadInterval, 重读间隔，单位为秒，默认不重读 Profile.reloadInterval，同上，即将作废 扩展 Profile支持扩展你自己的键值对格式资源，实现一个org.coodex.util.ProfileProvider放到SPI即可。 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-10-12 09:01:21 "},"coodex-utilities/org.coodex.util.Config.html":{"url":"coodex-utilities/org.coodex.util.Config.html","title":"Config","keywords":"","body":"Config 在设计Config之前，coodex-utitlies和concrete一直使用Profile作为系统配置信息获取的途径，随着concrete应用架构的扩展，对系统配置信息进行了封装，通过Config来隔离应用对实现的依赖。 接口定义 package org.coodex.config; public interface Configuration { /** * * 在多级命名空间中获取指定key的值，下级命名空间的值覆盖上级，例如 * config.get(\"key\",\"a\",\"b\",\"c\") * 则 * a/b/c/key 高于 * a/b/key 高于 * a/key 高于 * key * * * @param key * @return */ String get(String key, String... namespaces); T getValue(String key, T defaultValue, String... namespace); } usage coodex-utilities中提供了一个Configuartion的门面，提供快捷获取配置的使用方式。 Config.get(String key, String... namespace) Config.getValue(String key, T defaultValue, String... namespace) Config.getArray(String key, String... namespace) Config.getArray(String key, String delim, String[] defaultValue, String... namespaces) coodex-utitlies基于Profile实现了一个Configuration，后续concrete会提供基于配置中心的实现，方便集群应用的配置获取 在基于Profile的实现中，命名空间使用.链接，如Configuratio注释中的案例优先级则为： Profile a.b.c 中的key Profile a.b 中的key Profile a 中的key 默认Profile中的key 默认Profile，非concrete环境是coodex,concrete环境是concrete © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:28:27 "},"coodex-utilities/org.coodex.util.Renderer.html":{"url":"coodex-utilities/org.coodex.util.Renderer.html","title":"Renderer","keywords":"","body":"数据渲染器 接口 /** * @param template 待渲染的模板 * @param objects 渲染参数，支持{@link java.util.function.Supplier} * @return 渲染后的字符串 */ public static String render(String template, Object... objects) 扩展 实现org.coodex.util.RenderService，放到SPI中，选择策略为基于模板的选择，如SPI中针对当前模板无可用服务时，则原样返回模板。 已有的实现 基于java.text.MessageFormat的实现，开箱即用，支持Supplier。 示例： System.out.println(Renderer.render( \"您好，{0}。今天是{1,date,yyyy-MM-dd}，当前时间{1,time,HH:mm:ss}，您的服务号是{2,number,000}。祝您生活愉快。\", \"Davidoff\", new Date(), 3)); 您好，Davidoff。今天是2020-05-10，当前时间09:27:57，您的服务号是003。祝您生活愉快。 基于freemarker的实现，渲染变量从o1开始顺序命名，支持Supplier。 org.coodex coodex-renderer-freemarker ${coodex.libraries.version} 使用示例： System.out.println(Renderer.render(\"现在时刻是 ${o1}\",Common.now())); Map map = new HashMap<>(); map.put(\"test\",\"test\"); System.out.println(Renderer.render(\"测试：${o1.test}\", map)); System.out.println(Renderer.render(\"测试：${o2!\\\"xxx\\\"}\", map)); 现在时刻是 2020-05-10 10:45:41 测试：test 测试：xxx © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-10 10:48:14 "},"coodex-utilities/org.coodex.util.I18N.html":{"url":"coodex-utilities/org.coodex.util.I18N.html","title":"I18N 国际化","keywords":"","body":"I18N i18n: internationalization，国际化 usage // key 为 a.b.c.d 形式 I18N.translate(key); I18N.translate(key, locale); // 使用参数对翻译后的模板进行渲染 I18N.render(key, parameters); I18N.render(key, locale), parameters; render接口参见 Renderer 例如，我们要支持一个app.title的国际化，在英文环境为My Application，在中文环境显示我的应用，那么只需要在资源目录的i18n下的任意目录中建一套资源：app.yml,app_en_US.yml，app_zh_CN.yml 此案例使用yml文件进行示例，也支持properties文件 app.yml # 默认 app: title: My Application app_en_US.yml # 英文环境 app: title: My Application app_zh_CN.yml # 中文环境 app: title: 我的应用 代码中使用 System.out.println(I18N.translate(\"app.title\")); 不同的语言运行环境可以获取到不同的值。 说明 coodex-utitlites提供了一个实现作为I18N默认行为，基于Profile的国际化 i18n资源文件放在resources/i18n下，ProfileBasedTranslateService会自动检索，减少配置工作量 资源文件支持yaml(依赖snakeyaml)和properties 资源文件命名规范为namespace(_language)(_COUNTRY).yml|yaml|properties namespace可以是多级，例如a.b.c，表明此命名空间下的i18n资源可在此文件中查找，资源内容中应该包含a.b.c.** language可选，参考java.util.Locale.getISOLanguages()，大小写不敏感，推荐小写 country可选，参考java.util.Locale.getISOCountries(), 大小写不敏感，推荐大写 检索优先级 coodex.resource.path中的资源高于其他 同在coodex.resource.path中的资源，按照顺序，越靠前优先级越高 文件系统 高于jar包，方便资源修改 名称不同的，越长越优先（匹配度越高） 名称相同的，目录越深越优先 深度相同的，按包字典序 有language优先 有country优先 按profile支持的文件扩展名顺序 concrete-core中也提供了一个实现，基于jdk的ResourceBundles，已不推荐使用，保留对之前版本concrete的兼容性。 i18n还提供了一个扩展点org.coodex.util.DefaultLocaleProvider，用于获取默认的Locale，默认是根据当前运行的语言环境获取Locale。concrete-core中提供了一个基于ConcreteService调用者的语言环境作为默认环境的DefaultLocaleProvider，从而达到一套服务对多语言客户端的I18N. © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-10 11:52:22 "},"coodex-utilities/org.coodex.util.Retry.html":{"url":"coodex-utilities/org.coodex.util.Retry.html","title":"轻量级重试机制","keywords":"","body":"轻量级重试机制 在异步任务的场景中，为了保证正确及最终一致性，我们通常需要多次尝试直到任务成功或者尝试次数大于阈值。org.coodex.util.Retry基于这种场景提供了一个轻量级的解决方案。 示例： Retry.newBuilder() // // 最大尝试次数 // .maxTimes(3) // // 第一次执行延迟时间，默认为0 // .initDelay(20, TimeUnit.SECONDS) // // 延迟策略 // .next(new Retry.TimeUnitNextDelay(TimeUnit.SECONDS) { // @Override // protected long delay(int times) { // return 5; // } // }) // // 指定调度线程池 // .scheduler(ExecutorsHelper.newSingleThreadScheduledExecutor(\"test\")) // // 指定任务执行线程池，ScheduledExecutorService的线程数没法伸缩，所以，通过两个线程池来完成， // // 维持一个较小的ScheduledExecutorService进行任务调度，使用可伸缩ExecutorService进行任务执行 // .executor(ExecutorsHelper.newLinkedThreadPool( // 1, 16, Integer.MAX_VALUE >> 1, 1L, \"test-executor\" // )) // //指定任务名 // .named(\"TaskTest\") // // or supplier方式指定任务名 // .named(() -> \"TaskTest\") // //每次失败触发 // .onFailed((start, times, throwable) -> // log.info(\"on failed: {}, {}, {}\", Common.calendarToStr(start), times, throwable == null ? \"\" : throwable.getLocalizedMessage())) // // 当任务尝试数超出最大阈值依然失败时的handle // .onAllFailed((start, times) -> log.info(\"all failed\")) .build() // 要多次尝试执行的任务 .execute(times -> { log.debug(\"times: {}\", times); if (times % 2 == 0) { throw new RuntimeException(\"mock exception:\" + times); } return times == 5; }); © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:09:05 "},"coodex-utilities/org.coodex.util.Tracer.html":{"url":"coodex-utilities/org.coodex.util.Tracer.html","title":"Tracer","keywords":"","body":"Tracer 调式环境中或生产环境碰到性能问题时，可以通过tracer来输出相关信息。使用自定义属性-Dorg.coodex.util.Tracer=true开启 usage System.out.println( Tracer.newTracer() // // org.slf4j.Logger // .logger(log) // // logger will be named after clazz // .logger(String.class) // // logger name // .logger(\"TEST\") // // tracer名 // .named(\"test\") // // supplier方式指定tracer名 // .named(() -> \"test\") // 需要跟踪记录的代码段 .trace(() -> { try { Tracer.putTrace(\"hello\", \"coodex\"); // 需要跟踪的信息项 Tracer.start(\"case1\"); Clock.sleep(1000); Tracer.end(\"case1\"); Tracer.start(\"case2\"); Clock.sleep(300); Tracer.end(\"case2\"); if (new Random().nextBoolean()) throw new RuntimeException(\"em~~~~\"); else return \"hello tracer.\"; } catch (Throwable th) { throw rte(th); } }) ); © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:16:26 "},"coodex-utilities/org.coodex.util.CRC.html":{"url":"coodex-utilities/org.coodex.util.CRC.html","title":"CRC","keywords":"","body":"CRC - Cyclic redundancy check 主要用于各种算法的CRC运算。 coodex crc 实际上是基于 https://github.com/snksoft/java-crc 进行的修改和补充 各种算法参数源于 https://crccalc.com/ 支持的算法包括： CRC-8 CRC8(new Parameters(8, 0x07, 0x00, false, false, 0x0)) CRC8_CDMA2000(new Parameters(8, 0x9b, 0xff, false, false 0x0)) CRC8_DARC(new Parameters(8, 0X39, 0X00, true, true, 0x0)) CRC8_DVB_S2(new Parameters(8, 0xd5, 0x00, false, false, 0x0)) CRC8_EBU(new Parameters(8, 0x1d, 0xff, true, true, 0x0)) CRC8_I_CODE(new Parameters(8, 0x1d, 0xfd, false, false, 0x0)) CRC8_ITU(new Parameters(8, 0x07, 0x00, false, false, 0x55)) CRC8_MAXIM(new Parameters(8, 0X31, 0X00, true, true, 0x00)) CRC8_ROHC(new Parameters(8, 0x07, 0xff, true, true, 0x00)) CRC8_WCDMA(new Parameters(8, 0X9B, 0X00, true, true, 0x00)) CRC-16 CRC16_CCITT_FALSE(new Parameters(16, 0x1021, 0x00FFFF, false, false, 0x0)) CRC16_ARC(new Parameters(16, 0x8005, 0x0000, true, true, 0x0)) CRC16_AUG_CCITT(new Parameters(16, 0x1021, 0x1D0F, false, false, 0x0)) CRC16_BUYPASS(new Parameters(16, 0x8005, 0x0000, false, false, 0x0)) CRC16_CDMA2000(new Parameters(16, 0xC867, 0xFFFF, false, false, 0x0)) CRC16_DDS110(new Parameters(16, 0x8005, 0x800d, false, false, 0x0)) CRC16_DECT_R(new Parameters(16, 0x0589, 0x0000, false, false, 0x0001)) CRC16_DECT_X(new Parameters(16, 0x0589, 0x0000, false, false, 0x0)) CRC16_DNP(new Parameters(16, 0x3d65, 0x0000, true, true, 0xffff)) CRC16_EN13757(new Parameters(16, 0x3d65, 0x0000, false, false, 0xffff)) CRC16_GENIBUS(new Parameters(16, 0x1021, 0x00FFFF, false, false, 0xffff)) CRC16_MAXIM(new Parameters(16, 0x8005, 0x0000, true, true, 0xffff)) CRC16_MCRF4XX(new Parameters(16, 0x1021, 0x00FFFF, true, true, 0x0)) CRC16_RIELLO(new Parameters(16, 0x1021, 0x00B2AA, true, true, 0x0)) CRC16_T10DIF(new Parameters(16, 0x8bb7, 0x0000, false, false, 0x0000)) CRC16_TELEDISK(new Parameters(16, 0xa097, 0x0000, false, false, 0x0000)) CRC16_TMS37157(new Parameters(16, 0X1021, 0X89EC, true, true, 0x0000)) CRC16_USB(new Parameters(16, 0X8005, 0xffff, true, true, 0xffff)) CRC_A(new Parameters(16, 0x1021, 0xc6c6, true, true, 0x0)) CRC16_KERMIT(new Parameters(16, 0x1021, 0x0000, true, true, 0x0)) CRC16_MODBUS(new Parameters(16, 0X8005, 0XFFFF, true, true, 0x0)) CRC16_X25(new Parameters(16, 0x1021, 0xffff, true, true, 0xffff)) CRC16_XMODEM(new Parameters(16, 0x1021, 0x0000, false, false, 0x0000)) CRC32 CRC32(new Parameters(32, 0x04C11DB7, 0xFFFFFFFF, true, true, 0xFFFFFFFF)) CRC32_BZIP2(new Parameters(32, 0x04C11DB7, 0xFFFFFFFF, false, false, 0xFFFFFFFF)) CRC32C(new Parameters(32, 0x1EDC6F41, 0xFFFFFFFF, true, true, 0xFFFFFFFF)) CRC32D(new Parameters(32, 0xA833982B, 0xFFFFFFFF, true, true, 0xFFFFFFFF)) CRC32_MPEG2(new Parameters(32, 0x04C11DB7, 0xFFFFFFFF, false, false, 0x00000000)) CRC32_POSIX(new Parameters(32, 0x04C11DB7, 0x00000000, false, false, 0xFFFFFFFF)) CRC32Q(new Parameters(32, 0x814141AB, 0x00000000, false, false, 0x00000000)) CRC32_JAMCRC(new Parameters(32, 0x04C11DB7, 0xFFFFFFFF, true, true, 0x00000000)) CRC32_XFER(new Parameters(32, 0x000000AF, 0x00000000, false, false, 0x00000000)) usage // content是一个字节数组 CRC.calculateCRC(CRC.Algorithm.CRC16_XMODEM, content); © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 08:50:04 "},"coodex-utilities/org.coodex.util.Polygon.html":{"url":"coodex-utilities/org.coodex.util.Polygon.html","title":"Polygon 多边形工具","keywords":"","body":"多边形工具 根据多个二维坐标(double，double，有序，最后一个点自动连接到起点)构建一个多边形，目前提供了一个判定一个坐标点是否在多边形内的接口。 判定一个坐标点是否在多边形内，主要算法是射线法和回转法，Polygon都做了实现，在调用inPolygon接口时，可以传入枚举值，默认为回转法。 应用场景，电子围栏等。 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 10:42:42 "},"coodex-utilities/org.coodex.util.Section.html":{"url":"coodex-utilities/org.coodex.util.Section.html","title":"Section 线段","keywords":"","body":"Section 一维空间(必须是Comarable的)上的线段，可以进行合并，减法，交集等操作。 import org.coodex.util.Section; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.StringJoiner; public class IntSection extends Section { public static final Builder builder = IntSection::new; protected IntSection(Integer start, Integer end) { super(start, end); } private static void trace(List list) { if (list == null || list.size() == 0) { System.out.println(\"empty\"); return; } StringJoiner joiner = new StringJoiner(\", \"); list.forEach(section -> joiner.add(section.toString())); System.out.println(joiner.toString()); } public static void main(String[] args) { IntSection section1 = builder.create(0, 3);// 创建一个[0,3]的线段 IntSection section2 = builder.create(5, 7); //创建一个[5,7]的线段 IntSection section3 = builder.create(1, 6);// 创建一个[1,6]的线段 IntSection section4 = builder.create(-1, 10);//创建[-1.10]的线段 // 合并 trace(Section.merge(Arrays.asList(section1, section2), builder)); trace(Section.merge(Arrays.asList(section1, section2, section3), builder)); // 交集 trace(Section.intersect(Collections.singletonList(section1), Collections.singletonList(section2), builder)); trace(Section.intersect(Arrays.asList(section1, section2), Collections.singletonList(section3), builder)); // 减 trace(Section.sub(Collections.singletonList(section4), Arrays.asList(section1, section2), builder)); } @Override public String toString() { return \"[\" + getStart() + \", \" + getEnd() + \"]\"; } } [0, 3], [5, 7] [0, 7] empty [1, 3], [5, 6] [-1, 0], [3, 5], [7, 10] © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 12:05:27 "},"coodex-utilities/org.coodex.util.clock.html":{"url":"coodex-utilities/org.coodex.util.clock.html","title":"天上人间","keywords":"","body":"天上人间 重要的事情说三遍：不是那个“天上人间”！！！不是那个“天上人间”！！！不是那个“天上人间”！！！因为那个天上人间已经没了，摊手 记得小时候看西游记，“天上一天，人间一年”，相同的时间在不同的“界”有不同的流失速度。coodex的天上人间提供了一种应用环境界（人间）与客观时间界（天上）不同时间流速的方案。 假设，我们的系统需要通过一种测试手段来证明，系统在一年内能够稳定运行，难道说我们花一年的时间来运行测试证明么？能不能用更少的时间？如果一个有个环境可以通过1个月来完成一年的运行情况（12倍率）肯定能够极大的提高效率。如果一天完成一年呢（365倍率）？这就是天上人间了。 我们做个案例来看，每隔一小时输出一下当前时刻，执行10次，正常情况下需要10个小时，我们用天上人间看看： package org.coodex.concrete.demo.boot; import org.coodex.util.Clock; import org.coodex.util.Common; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ClockDemo { private final static Logger log = LoggerFactory.getLogger(ClockDemo.class); private static final long AN_HOUR = 60 * 60 * 1000; public static void main(String[] args) throws InterruptedException { for (int i = 1; i 跑起来，我们十小时以后见。。。。 好吧，我们来开启时间加速，加上参数-Dorg.coodex.util.Clock.magnification=365 09:47:24.270 [main] DEBUG org.coodex.util.clock.AbstractClockAgent - ClockAgent[org.coodex.util.clock.DefaultClockAgent]: magnification: 365.0 baseLine: 2019-08-14 09:47:23.039 start at: 2019-08-14 09:47:23.039 09:47:34.138 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 1: 2019-08-14 10:54:54 09:47:44.003 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 2: 2019-08-14 11:54:54 09:47:53.866 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 3: 2019-08-14 12:54:54 09:48:03.730 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 4: 2019-08-14 13:54:55 09:48:13.593 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 5: 2019-08-14 14:54:55 09:48:23.457 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 6: 2019-08-14 15:54:55 09:48:33.358 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 7: 2019-08-14 16:55:09 09:48:43.221 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 8: 2019-08-14 17:55:09 09:48:53.085 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 9: 2019-08-14 18:55:09 09:49:02.948 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 10: 2019-08-14 19:55:09 我们看到，天上在一分半钟完成了人间的10个小时 :) 好，继续，我们为了模拟人间运行，会有多个应用来模拟请求，每个应用都有自己的环境，咋整？ coodex提供了一个ClockAgentService和RemoteClockAgent来让各个应用采用统一的人间环境。 启动时间管理中心 package org.coodex.concrete.demo.boot; import org.coodex.util.Clock; import org.coodex.util.Common; import org.coodex.util.clock.ClockAgentService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class ClockDemo { private final static Logger log = LoggerFactory.getLogger(ClockDemo.class); private static final long AN_HOUR = 60 * 60 * 1000; public static void main(String[] args) throws InterruptedException { // 启动时间管理中心 new ClockAgentService().start(); for (int i = 1; i 在SPIMETA-INF/services/org.coodex.util.clock.ClockAgent中选择使用RemoteClockAgent org.coodex.util.clock.RemoteClockAgent 增加-Dorg.coodex.util.Clock.remoteHost=localhost -Dorg.coodex.util.Clock.remotePort=8360 10:03:01.604 [main] DEBUG org.coodex.util.clock.AbstractClockAgent - ClockAgent[org.coodex.util.clock.DefaultClockAgent]: magnification: 365.0 baseLine: 2019-08-14 10:03:00.495 start at: 2019-08-14 10:03:00.495 10:03:01.609 [main] INFO org.coodex.concrete.spring.SpringBeanProvider - spring bean provider not initialized, org.coodex.util.clock.ClockAgent not load from spring bean provider. 10:03:01.620 [Thread-0] INFO org.coodex.util.clock.ClockAgentService - Clock Agent Service start [0.0.0.0:8360].... 10:03:02.502 [main] DEBUG org.coodex.util.clock.AbstractClockAgent - ClockAgent[org.coodex.util.clock.RemoteClockAgent]: magnification: 365.0 baseLine: 2019-08-14 10:03:00.495 start at: 2019-08-14 10:03:00.495 10:03:12.367 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 1: 2019-08-14 11:15:13 10:03:22.231 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 2: 2019-08-14 12:15:14 10:03:32.095 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 3: 2019-08-14 13:15:14 10:03:41.959 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 4: 2019-08-14 14:15:14 10:03:51.822 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 5: 2019-08-14 15:15:14 10:04:01.686 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 6: 2019-08-14 16:15:15 10:04:11.549 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 7: 2019-08-14 17:15:15 10:04:21.413 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 8: 2019-08-14 18:15:15 10:04:31.278 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 9: 2019-08-14 19:15:16 10:04:41.141 [main] INFO org.coodex.concrete.demo.boot.ClockDemo - 10: 2019-08-14 20:15:16 上面的案例中，我们看到了使用参数运行的方式，同样的，天上人间也支持Configuration，命名空间为clock 参数说明： org.coodex.util.Clock.magnification: Float，人间时间倍率 org.coodex.util.Clock.baseline: String，人间时间基线，不设置则使用人间环境启动时间 org.coodex.util.Clock.remoteHost: String，人间时间管理的主机地址，使用RemoteClockAgent时生效 org.coodex.util.Clock.remotePort: int, 人间时间管理的服务端口，默认8360(0x1978 + 0x0730，嗯，好像暴露年龄了)，使用RemoteClockAgent时生效 接口说明 Clock.currentTimeMillis(long): 对标System.currentTimeMillis(long)，获取人间当前时间的毫秒数 Clock.getCalendar(): 对标Calendar.getInstance()，获取人间当前时间的Calendar对象 Clocl.objWait(Object, long): 对标Object.wait(long)，根据对象获得最长人间时间为指定参数的锁 Clock.toMillis(): 对标TimeUnit.toMillis() Clock.sleep(long): 对标Thread.sleep(long)，当前休眠一定人间时长(毫秒数) Clock.sleep(TimeUnit, long): 对标TimeUnit.sleep(long) coodex及concrete时间相关都已经统一到天上人间。 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:24:07 "},"coodex-utilities/org.coodex.concurrent.html":{"url":"coodex-utilities/org.coodex.concurrent.html","title":"并发通用库","keywords":"","body":"并发通用库 线程池助手 org.coodex.concurrent.ExecutorsHelper类似于java.util.concurrent.Executors的作用，不同的是： 接口提供了定义线程池名称的功能 提供了基于任务优先级的线程池，将要执行的任务会按照优先级送入线程池执行，并且，线程优先级也会设置成按照带优先级任务的优先级，高优先级的任务将拿到更多的系统资源 扩展了有界阻塞队列，剥离队列大小与线程池最大线程数数的耦合，线程池最大线程数 低于 任务最大值时可用，线程满时，任务队列可以继续容纳一定数量的任务，尝试在线程数和任务数之间达到一个平衡 TODO: 编写文档的时候想起来的，可以做一个令牌桶的有界队列模型，去峰值 防反跳和连击 前端用得比较多的技术，主要作用是减少频繁发生的事件的处理次数。 可以用于实时性要求不是极高的级频繁数据写入场景。 package org.coodex.concrete.demo.boot; import org.coodex.concurrent.Coalition; import org.coodex.concurrent.Debouncer; import org.coodex.concurrent.Throttler; import org.coodex.util.Common; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class CoalitionDemo { private final static Logger log = LoggerFactory.getLogger(CoalitionDemo.class); private static void test(Coalition coalition) throws InterruptedException { for (int i = 0; i ( arg -> log.info(\"Debouncer saved: {}\", arg), 15 )); // 最多500毫秒执行一次 test(new Throttler<>( arg -> log.info(\"Throttler saved: {}\", arg), 500 )); } } 14:34:09.916 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 45 14:34:10.069 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 66 14:34:10.209 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 81 14:34:10.885 [CoalitionPool-1] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 173 14:34:10.905 [CoalitionPool-3] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 174 14:34:11.132 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 203 14:34:11.339 [CoalitionPool-1] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 227 14:34:11.358 [CoalitionPool-3] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 230 14:34:11.409 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 236 14:34:17.179 [CoalitionPool-2] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Debouncer saved: 999 14:34:17.334 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 0 14:34:17.837 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 61 14:34:18.339 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 118 14:34:18.843 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 178 14:34:19.351 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 245 14:34:19.861 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 317 14:34:19.861 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 318 14:34:20.370 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 385 14:34:20.881 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 453 14:34:21.382 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 529 14:34:21.889 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 606 14:34:22.392 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 675 14:34:22.899 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 756 14:34:23.402 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 815 14:34:23.912 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 885 14:34:24.416 [main] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 947 14:34:25.049 [CoalitionPool-3] INFO org.coodex.concrete.demo.boot.CoalitionDemo - Throttler saved: 999 可以看到，原本需要执行2000次的场景，只进行了20次上下 并行任务 org.coodex.concurrent.Parallel 提供了一个多任务并行处理功能，从根本上来讲，其实就是简化了CountDownLatch的使用。 package org.coodex.concrete.demo.boot; import com.alibaba.fastjson.JSON; import org.coodex.concurrent.ExecutorsHelper; import org.coodex.concurrent.Parallel; import org.coodex.util.Clock; import org.coodex.util.Common; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.ArrayList; import java.util.List; public class ParallelDemo { private final static Logger log = LoggerFactory.getLogger(ParallelDemo.class); public static void main(String[] args) { List runnables = new ArrayList<>(); for (int i = 0; i { try { Clock.sleep(Common.random(3000)); log.info(\"task {} finished.\", finalI); } catch (InterruptedException ignore) { } }); } Parallel.Batch batch = new Parallel( // 5个线程来执行并行任务 ExecutorsHelper.newFixedThreadPool(5, \"parallel\") ).run(runnables.toArray(new Runnable[0])); log.info(\"all task finished.\"); log.info(\"\\n{}\", JSON.toJSONString(batch, true)); } } 14:48:34.945 [parallel-3] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 2 finished. 14:48:35.908 [parallel-5] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 4 finished. 14:48:37.242 [parallel-2] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 1 finished. 14:48:37.288 [parallel-4] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 3 finished. 14:48:37.377 [parallel-1] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 0 finished. 14:48:37.398 [parallel-3] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 5 finished. 14:48:37.776 [parallel-3] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 10 finished. 14:48:38.640 [parallel-5] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 6 finished. 14:48:38.827 [parallel-4] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 8 finished. 14:48:39.782 [parallel-4] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 13 finished. 14:48:39.892 [parallel-4] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 14 finished. 14:48:39.910 [parallel-1] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 9 finished. 14:48:39.991 [parallel-2] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 7 finished. 14:48:40.596 [parallel-5] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 12 finished. 14:48:40.719 [parallel-3] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 11 finished. 14:48:41.043 [parallel-2] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 17 finished. 14:48:41.321 [parallel-3] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 19 finished. 14:48:41.478 [parallel-5] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 18 finished. 14:48:42.145 [parallel-4] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 15 finished. 14:48:42.333 [parallel-1] INFO org.coodex.concrete.demo.boot.ParallelDemo - task 16 finished. 14:48:42.333 [main] INFO org.coodex.concrete.demo.boot.ParallelDemo - all task finished. 可以看到，main线程等到所有任务执行完成后才输出all task finished. { \"end\":1565765322333, \"id\":\"2c963b1966f941e2870fcdd68fdb74f6\", \"start\":1565765314391, \"tasks\":[ { \"end\":1565765317377, \"finished\":true, \"id\":1, \"start\":1565765314393, \"timeConsuming\":2984 }, { \"end\":1565765317242, \"finished\":true, \"id\":2, \"start\":1565765314393, \"timeConsuming\":2849 }, { \"end\":1565765314945, \"finished\":true, \"id\":3, \"start\":1565765314394, \"timeConsuming\":551 }, { \"end\":1565765317288, \"finished\":true, \"id\":4, \"start\":1565765314394, \"timeConsuming\":2894 }, { \"end\":1565765315908, \"finished\":true, \"id\":5, \"start\":1565765314397, \"timeConsuming\":1511 }, { \"end\":1565765317398, \"finished\":true, \"id\":6, \"start\":1565765314945, \"timeConsuming\":2453 }, { \"end\":1565765318640, \"finished\":true, \"id\":7, \"start\":1565765315908, \"timeConsuming\":2732 }, { \"end\":1565765319991, \"finished\":true, \"id\":8, \"start\":1565765317242, \"timeConsuming\":2749 }, { \"end\":1565765318827, \"finished\":true, \"id\":9, \"start\":1565765317288, \"timeConsuming\":1539 }, { \"end\":1565765319910, \"finished\":true, \"id\":10, \"start\":1565765317377, \"timeConsuming\":2533 }, { \"end\":1565765317776, \"finished\":true, \"id\":11, \"start\":1565765317398, \"timeConsuming\":378 }, { \"end\":1565765320719, \"finished\":true, \"id\":12, \"start\":1565765317776, \"timeConsuming\":2943 }, { \"end\":1565765320596, \"finished\":true, \"id\":13, \"start\":1565765318640, \"timeConsuming\":1956 }, { \"end\":1565765319782, \"finished\":true, \"id\":14, \"start\":1565765318827, \"timeConsuming\":955 }, { \"end\":1565765319892, \"finished\":true, \"id\":15, \"start\":1565765319782, \"timeConsuming\":110 }, { \"end\":1565765322145, \"finished\":true, \"id\":16, \"start\":1565765319892, \"timeConsuming\":2253 }, { \"end\":1565765322333, \"finished\":true, \"id\":17, \"start\":1565765319910, \"timeConsuming\":2423 }, { \"end\":1565765321043, \"finished\":true, \"id\":18, \"start\":1565765319991, \"timeConsuming\":1052 }, { \"end\":1565765321478, \"finished\":true, \"id\":19, \"start\":1565765320596, \"timeConsuming\":882 }, { \"end\":1565765321321, \"finished\":true, \"id\":20, \"start\":1565765320719, \"timeConsuming\":602 } ], \"timeConsuming\":7942 } 返回值对象中，会把每个任务的信息和总览详细返回。 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2019-08-14 14:54:29 "},"coodex-utilities/org.coodex.closure.html":{"url":"coodex-utilities/org.coodex.closure.html","title":"闭包","keywords":"","body":"闭包 闭包可以将数据放入上下文中，无需通过大量的参数调用来传递必须的数据。 闭包由上下文和闭包执行体两部分构成，使用时，大致模式如下 上下文实例.call(需要放入上下文的数据， 闭包执行体) coodex-utilites提供了两种闭包上下文 org.coodex.closure.StackClosureContext StackClosureContext是一个基于栈模型的闭包上下文，每一次call，都会把最进的数据入栈，执行完后数据出栈，在闭包执行体中获取上下文数据时，永远时最近的那个。 org.coodex.closure.MapClosureContext MapClosureContext也是一种StackClosureContext，不同的是，上下文中的数据是一个Map，MapClosureContext为执行体提供了按键获取上下文数据的接口，可以同时把多个数据放入一层闭包环境，并且，MapClosureContext还有继承策略，当前层的Map中会继承上一层闭包环境中的Map，相同键值采用就近原则，近的覆盖远的。 在coodex-mock-impl和concrete中，大量使用了闭包，减少了很多复杂度。 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:23:53 "},"coodex-mock/":{"url":"coodex-mock/","title":"数据模拟","keywords":"","body":"coodex-mock-spec 尝试定义一种能够贴近实际情况的模拟数据规范，一次配置，到处使用。 先不多说，由浅入深，一步步走着看。 最简单的示例 org.coodex coodex-mock-spec ${coodex.libraries.version} org.coodex coodex-mock-impl ${coodex.libraries.version} // 使用默认的配置生成一个随机字符串 Mocker.mock(String.class); 结果实例：nMNGvUiJk 好像没什么鸟用啊。这不是coodex-mock的推荐用法，下面我们一点点的来使用mock规范。 pojo 定义一个pojo class Pojo{ // 为了简化代码，我们使用公有属性 public String stringValue; public Integer integerValue; public Float floatValue; public Boolean booleanValue; } System.out.println( JSON.toJSONString( Mocker.mock(Pojo.class), SerializerFeature.PrettyFormat ) ); { \"booleanValue\":false, \"floatValue\":-1.0027583E38, \"integerValue\":-815963263, \"stringValue\":\"fbtxY4\" } 这数据确实是随机生成了，可还是没什么鸟用，怎么办？ 数字模拟的定义 我们预期floatValue的模拟范围是从 -2.0f 到 2.0f，integerValue的模拟范围是 0到4以及9 @Mock.Number(\"[0,4],9\") public Integer integerValue; @Mock.Number(\"[-2.0f, 2.0f]\") public Float floatValue; 再run一下 { \"booleanValue\":false, \"floatValue\":0.84, \"integerValue\":3, \"stringValue\":\"sRC0HpXql\" } 这样，这两个值被限定在我们的预期范围里了 @Mock.Number修饰说明 value（） 指定模拟范围，不指定则为该类型数据得全域模拟 范围包括两种：连续范围，单值范围 连续范围规则如下 '[' - 表示一个连续范围开始，且包含此值，float double及其包装类无效 '(' - 表示一个连续范围开始，不包含此值 ']' - 表示一个连续范围结束，且包含此值，float double及其包装类无效 ')' - 表示一个连续范围结束，不包含此值 连续范围的起止值使用 ',' 分隔 例如 (-100.0f, 200.5f] 单值范围直接用数值描述 多个单值范围或连续范围使用 ',' 分割 特别的，MIN代表该类型的最小值，MAX代表该类型的最大值，不区分大小写，例如[min,0),MAX,15 各个范围不需要有序，各自模拟的权重，单值为1，连续范围依据： 整数类型的，此连续范围内整数的个数来确定 浮点类型的，根据跨越的整数单位来确定 最大不超过1000，最小为1 例如： 10,[-1,5],8,(20,30),35 byte,short,int,long及其包装类，以0x开头则表示以16进制解析 digits(): 小数点后面的位数，对不需要用科学计数法的double/float及其包装类有效，负数表示不用处理，默认为2 String模拟的定义 我们对stringValue的预期是以下内容中的一个： coodex concrete 真棒 @Mock.String(range = {\"coodex\", \"concrete\", \"真棒!\"}) public String stringValue; { \"booleanValue\":true, \"floatValue\":-1.44, \"integerValue\":0, \"stringValue\":\"真棒!\" } @Mock.String用法 模拟配置优先级： txtResource() 存在且有内容时，在资源文件行中模拟 range() 非0长字符串，在range范围内模拟 charCodeSet() 非0元素宿数组时，结合minLength(),maxLength()模拟 默认，'0'-'9','A'-'Z','a'-'z'范围内，结合minLength(),maxLength()模拟 String模拟的定义 我们对stringValue的预期是以下内容中的一个： coodex concrete 真棒 @Mock.String(range = {\"coodex\", \"concrete\", \"真棒!\"}) public String stringValue; { \"booleanValue\":true, \"floatValue\":-1.44, \"integerValue\":0, \"stringValue\":\"真棒!\" } 点我看@Mock.String的说明 @Mock.Nullable 如果我们需要一个属性有几率返回null时，可以使用@Mock.Nullable进行修饰，例如 @Mock.String(range = {\"coodex\", \"concrete\", \"真棒!\"}) @Mock.Nullable(probability = 0.3d) public String stringValue; 这样stringValue就有30%几率为null 其他基础类型模拟 @Mock.Char 支持的类型, char及其包装类，String 模拟优先级: value() 为非0元素集合，则在集合范围内模拟 range() 为有长度的字符串时，在字符串的字符中模拟 默认：'0'-'9','A'-'Z','a'-'z' 中模拟 @Mock.Boolean 布尔单值模拟器,支持类型: boolean, Boolean: 布尔值 true, false byte, int, short, long及其包装类: 默认true - 1; false - 0，可通过intTrue和intFalse更改 char及其包装类: 默认 true - T; false - F，可通过charTrue和charFalse更改 String: 默认true - \"true\"; false - \"false\"，可通过strTrue, strFalse更改 属性类型循环 在需要模拟的数据中，可能会出现到自身循环关系的情况，例如，部门有个属性是上级部门，类型是一样一样的，如果不限制，那就是子子孙孙无穷尽，愚公移山了，我们可以通过设置循环层数来限定对象深度 @Mock.Depth(2) static class Pojo { @Mock.String(range = {\"coodex\", \"concrete\", \"真棒!\"}) @Mock.Nullable(probability = 0.5d) public String stringValue; @Mock.Number(\"[0,4],9\") public Integer integerValue; @Mock.Number(\"[-2.0f, 2.0f]\") public Float floatValue; public Boolean booleanValue; @Mock.Number(\"[0,4],9\") @Mock.Dimension(size = 5) public int[] intArray; public Pojo pojo; } { \"booleanValue\":false, \"floatValue\":-0.67, \"integerValue\":1, \"pojo\":{ \"booleanValue\":false, \"floatValue\":-1.81, \"integerValue\":1, \"stringValue\":\"coodex\" } } 我们可以看到pojo被模拟了两层 @Mock.Depth value(): 相同类型的深度，最小为1 集合或数组 集合或数组维度设置 我们为pojo增加一个属性 @Mock.Number(\"[0,4],9\") // 单值模拟设置 @Mock.Dimension(size = 5) public int[] intArray; { \"booleanValue\":false, \"floatValue\":1.89, \"intArray\":[1,9,4,4,2], \"integerValue\":1, \"stringValue\":\"coodex\" } @Mock.Dimension 用来定义多维（含一维）集合、数组的维度模拟信息，确定各维度的数组大小 size(): >0 表示固定值，负数表示允许为空，几率为size%，否则按照random(min, max)，默认0 nullProbability(): 为空的几率，默认不为空 min(): size max(): size ordered(): 仅对Collection Set Map有效，用以说明是否需要保证稳定性，默认为真 ordered()属性主要应用于后续序列模拟，到时候再说 @Mock.Dimensions 定义多维集合、数组各个维度的模拟配置 value(): 维度定义数组，当前属性上，多维度集合、数组的大小设置，按value的数组下标+1确定对应维度 same(): 相同维度的集合数组是否大小一致，默认一致 例如： @Mock.Dimensions( value = { @Mock.Dimension(size=2), @Mock.Dimension(min=3,max=10)) }, same = true ) String[][][] string3d; 模拟结果，string3d[0].length == string3d[1].length，same 为 false 时，则有可能不等 序列模拟器 对于集合，经常的，我们的应用系统数据有一定的规律，例如，从某一个时刻开始，每一定频率产生一个值。 下面我们做一个以一个固定频率的时刻序列来演示mock的序列模拟器 先定义一个序列模拟器工厂接口 public interface TimestampSequenceFactory extends SequenceMockerFactory { @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.METHOD}) @interface Interval { /** * @see java.util.Calendar * @return 单位 */ int timeUnit() default Calendar.MINUTE; int interval() default 10; } } Interval注解不是必须的，我们用他来演示如何设置序列发生器的参数 实现工厂和SequenceMocker public class TimestampSequenceFactoryImpl implements TimestampSequenceFactory { @Override public SequenceMocker newSequenceMocker(Annotation... annotations) { Interval interval = null; for (Annotation annotation : annotations) { if (annotation.annotationType().equals(Interval.class)) { interval = (Interval) annotation; break; } } return new TimestampSequence(interval); } static class TimestampSequence implements SequenceMocker { private final int timeUnit; private final int interval; private final Calendar timestamp = Calendar.getInstance(); TimestampSequence(Interval interval) { this.timeUnit = interval == null ? Calendar.MINUTE : interval.timeUnit(); this.interval = interval == null ? 10 : interval.interval(); // 初始化开始时间 timestamp.add(Calendar.DATE, -new Random().nextInt(10)); } @Override public String next() { timestamp.add(timeUnit, interval);// 增加一个时间间隔 return Common.calendarToStr(timestamp); } } } 把实现放到SPI支持的环境中。 下面以SPI为例演示 把实现类放到 resources/META-INF/services/org.coodex.mock.SequenceMockerFactory 中 好了，序列模拟器实现好了，开始配置 在之前的pojo上增加一个属性用来存放序列模拟器产生的值 @Mock.Dimension(size = 20, ordered = true) @Mock.Sequence(name = \"timestamp\", factory = TimestampSequenceFactory.class) @Mock.Inject(\"timestamp\") @TimestampSequenceFactory.Interval(interval = 1, timeUnit = Calendar.HOUR) public Set timestamp; 模拟结果大致为 { \"booleanValue\":false, \"floatValue\":1.9487758, \"integerValue\":2, \"timestamp\":[ \"2019-07-17 00:15:27\",\"2019-07-17 01:15:27\", \"2019-07-17 02:15:27\",\"2019-07-17 03:15:27\", \"2019-07-17 04:15:27\",\"2019-07-17 05:15:27\", \"2019-07-17 06:15:27\",\"2019-07-17 07:15:27\", \"2019-07-17 08:15:27\",\"2019-07-17 09:15:27\", \"2019-07-17 10:15:27\",\"2019-07-17 11:15:27\", \"2019-07-17 12:15:27\",\"2019-07-17 13:15:27\", \"2019-07-17 14:15:27\",\"2019-07-17 15:15:27\", \"2019-07-17 16:15:27\",\"2019-07-17 17:15:27\", \"2019-07-17 18:15:27\",\"2019-07-17 19:15:27\"] } 我们对timestamp属性上的注解简单说明一下 @Mock.Dimension,用来说明这个集合的维度信息，此案例中固定20长，ordered特别说明一下，对Map/Set/Collection有效，用以保证序列发生器产生的单值顺序不乱，你可以把ordered改为false对比一下 @Mock.Sequence 定义一个序列发生器 name(): 上下文中的名字。 这一版的coodex-mock设计上，引入了依赖注入理念，对于具体需要模拟的地方，指定好名称即可，由外部设置具体实现 factory(): 指定序列模拟器工厂类型，当需要用到是，由它负责生成一个SequenceMocker实例。 在本例中，我们看到，定义一个序列发生器看似很繁琐，要定义一个Factory的接口，然后写一个实现，这是推荐的实践方案，这种做法的好处在于，mock的实现与最终业务系统的实现是无关的，可以最大限度剥离业务系统与mock的环境隔离 @TimestampSequenceFactory.Interval(interval = 1, timeUnit = Calendar.HOUR) 这是我们自定义的注解，用来传递参数，本例中，我们把间隔设为1小时 @Mock.Inject 依赖注入的理念，用来指定当前单值模拟的时候使用哪个模拟器。 本案例中，@Mock.Sequence 和 @Mock.Inject 都放在了要模拟的属性上，这不是必须的，定义类的（后面还有几种）注解，只需要在被Inject之前定义好就行，而且重名的，会根据上下文就近原则进行注入 模拟一个Map 虽然coodex.org不推荐使用Map作为pojo传递数据，但是mock还是支持模拟Map的。 来吧，看看Map怎么定制模拟。说到这，忘了，约定大于配置，所有注解都是非必须的，也就是说，不加注解一样可以模拟数据，加了以后我们可以把mock做到更贴近实际系统数据，嘿嘿嘿，看出来作用了吗，一会再说。 增加一个Map属性 @Mock.String(range = {\"男\",\"女\"}) @Mock.Number(\"[60,80]\") public Map scores; { \"booleanValue\":true, \"floatValue\":0.62, \"integerValue\":0, \"scores\":{ \"男\":65, \"女\":62 }, \"stringValue\":\"concrete\" } 效果有了，不过，这种方式只适用于key/value类型不同的情况，coodex-mock在模拟Map的时候，会有一个优先级和容错程度，最大可能的保障可用性。 正确的使用方式是，使用@Mock.Key 和 @Mock.Value 进行注入。在注入之前，我们需要定义一个模拟设置 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) @Mock.Declaration //声明一个模拟配置 @interface Setting1{ //方式1 @Mock.String(range = {\"男\",\"女\"}) String testKey() default \"\"; //方式2 Mock.Number testValue() default @Mock.Number; } 然后把Map属性的注解改为 @Setting1(testValue = @Mock.Number(\"[60,80]\")) @Mock.Key(\"testKey\") @Mock.Value(\"testValue\") public Map scores; 结果大致如下 { \"floatValue\":-1.76, \"integerValue\":3, \"scores\":{ \"女\":64, \"男\":70 } } 在本例中，我们看到，声明一个模拟配置需要做的是，使用@Mock.Declaration装饰一个注解，然后把这个注解用到你的模拟上下文中即可。 定义配置有两种方式，一种是用明确的模拟器配置，方法名就是配置名，由@Mock.Inject/@Mock.Key/@Mock.Value使用 //方式1 @Mock.String(range = {\"男\",\"女\"}) String testKey() default \"\"; 这种方式下，模拟器配置是明确的，是固定的，好处在于可以定义多个模拟配置，对于带泛型的通用pojo有帮助，声明一个可以服务多种场景。 //方式2 Mock.Number testValue() default @Mock.Number; 这种方式下，可以在放入上下文的时候指定具体模拟配置，一个定义可以重复使用 以上两种方式是可以混用的，例如： @Mock.String(range = {\"男\",\"女\"}) Mock.Number map() default @Mock.Number; @Setting1(map = @Mock.Number(\"[60,80]\")) @Mock.Key(\"map\") @Mock.Value(\"map\") public Map scores; coodex-mock会根据多个模拟器配置选择合适的模拟器，优先级上，方式2 高于 方式1，方式1中（直接在属性上声明的也一样），则根据先后顺序 同样的，@Mock.Key/@Mock.Value也支持序列模拟器，在上下文中有同名的定义配置时，优先就近的序列模拟、然后是单值模拟 例如 @Mock.Dimension(size = 5) @Mock.Sequence(name = \"map\", factory = TimestampSequenceFactory.class) @TimestampSequenceFactory.Interval(interval = 1, timeUnit = Calendar.HOUR) @Setting1(map = @Mock.Number(\"[60,80]\")) @Mock.Key(\"map\") @Mock.Value(\"map\") public Map scores; { \"floatValue\":1.45, \"integerValue\":1, \"scores\":{ \"2019-07-12 10:37:19\":77, \"2019-07-12 11:37:19\":60, \"2019-07-12 12:37:19\":68, \"2019-07-12 13:37:19\":62, \"2019-07-12 14:37:19\":79 }, \"stringValue\":\"concrete\" } 属性关联 pojo的属性之间，通常会有一定的联系，为了更贴近真实数据，coodex-mock支持属性关联，我们来走一个例子。 定义一个pojo，x1,x2是加数，sum是和，我们要达到的模拟效果是，sum = x1 + x2 static class PojoAdd{ @Mock.Number(\"[0, 100)\") public int x1; @Mock.Number(\"[0, 100)\") public int x2; @Mock.Relation(dependencies = {\"x1\", \"x2\"}, strategy = \"add\") public int sum; } 注意sum属性的上指定了关联关系，依赖x1和x2，使用名称为add的策略。那这个策略在哪呢？我们往下看，实现这个策略并放到SPI中 import org.coodex.mock.AbstractRelationStrategy; import org.coodex.util.Parameter; public class RelationExample extends AbstractRelationStrategy { @Strategy(\"add\") public int add( @Parameter(\"x1\") int x1, @Parameter(\"x2\") int x2) { return x1 + x2; } } 如果你使用java 8的-parameters编译，那么@Parameter也不用加 定义一个公用方法，声明它是add依赖策略的算法，参数上，定义好是哪个属性。 { \"sum\":75, \"x1\":32, \"x2\":43 } 扩展 以上，单值、集合、序列的基本使用都涉及到了。那么问题来了，这些基本的能达到一定的效果，但是还有很多做不到的，怎么办？我们来自定义一个模拟中文姓名的 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER}) @Mock public @interface FullName { } 实现就不贴了，点我查看 coodex-mock除了定义规范以外，还根据历史经验，org.coodex.mock.ext下提供了一些模拟器 @DateTime， 时间戳模拟配置，支持java.util.Date/ java.util.Calendar/ String @EMail, 电子邮件模拟配置，支持String @FullName，中文姓名模拟，支持String @IdCard，身份证模拟，支持String @IpAddress, IP地址模拟，支持String/ int[]/ Integer[]/ byte[]/ Byte[] @VehicleNum, 车牌号模拟，支持String @Coordinates，经纬度模拟，支持float[]/ Float[]/ double[]/ Double[] @MobilePhoneNum，手机号模拟，支持String 应用场景 所有支持AOP 拦截器的传输POJO的场景下，前后端分离并行开发 concrete mock重构后的版本新增了concrete-core-mock模块，推荐的实践方案是，在原来发布服务的模块里，将其依赖进来，注意，使用test作用域，然后在test作用域的代码里随便建个class，main方法里写上SpringApplication.run(YourStarter.class, args)即可，巨省事 Spring MVC 点我查看示例 文档化 配置无配置的pojo 我们的系统通常会用到一些第三方的pojo数据结构，它们可不知道coodex-mock，怎么配置这些数据的mock呢？ 我们假设Pojo3rd就是一个第三方的数据，并且需要在我们的服务中用到 interface Pojo3rd{ String getVehicleNum(); } 我们看看怎么不改它代码的情况下进行配置 方案一 在mock.assign包下定义一个同结构的pojo，并在其属性上进行配置，例如： package mock.assign.example; import org.coodex.mock.Mock; import org.coodex.mock.ext.VehicleNum; import test.org.coodex.mock.impl.MockerTest; @Mock.Assignation(MockerTest.Pojo3rd.class)//指定给谁配置 public class Pojo3rdCase1 { @VehicleNum public String vehicleNum; } codoex-mock规范定义了MockerProvider的实现必须检查mock.assign包下所有带有@Mock.Assignation的类，将这些配置信息带入到模拟上下文中 { \"vehicleNum\":\"川Q52447\" } 方案二 使用注解定义，并放到上下文里 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.TYPE}) @Mock.Assignation(Pojo3rd.class)//指定给谁配置 @interface Pojo3rdCase2{ // 方法名对应pojo属性名 // 和@Mock.Declaration一样，两种模式，自行选择 MobilePhoneNum vehicleNum() default @MobilePhoneNum; } 如果直接模拟Pojo3rd的话，我们需要改改入口，把这个注解放进去 先在之前的Pojo类上定义Pojo3rdCase2，然后 System.out.println( JSON.toJSONString( Mocker.mock(Pojo3rd.class,Pojo.class.getAnnotations()), // { \"vehicleNum\":\"18192536319\" } 使用@Mock.Assignation的时候，和直接在Pojo上配置是一样一样的，也可以定义序列、依赖注入。 coodex-mock得益于coodex-utilities对泛型的支持，so，请大家放心食用。 enjoy it :) © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 13:41:55 "},"coodex-billing/":{"url":"coodex-billing/","title":"计费框架","keywords":"","body":"coodex billing 一个可复用的计费模型框架 maven org.coodex coodex-billing ${coodex.libraries.version} 主要对象 Chargeable，可计费对象，主要跟业务对应，由其决定计费的领域，例如：一次KTV消费，一顿饭、一次住宿、一次罚款、一次停车等等 Bill，一笔账单，包含计费明细 Calculator，费用计算器，根据可计费对象计算Bill Revision，计费时对计费的调整项目，例如：优惠券，其他消费抵扣，包月等等 Adjustment，对账单的调整项目，例如：账单比例优惠，抹零，附加费等等 按量计费 太简单，不多说。 时序计费 coodex-billing为时序计费提供了一个简单框架，主要对象包括： Period，时间段，包含开始时间，结束时间 TimeBasedChargeable，时序可计费对象，包含一个起止时间段，模型编码，模型参数id TimeBasedBill，包含时间段信息的账单 TimeBasedDetail，包含时间段信息的账单明细 BillingModel，时序计费的模型，也就是对应指定领域中一种具体的、完整的计费规则 BillingModel.Instance，计费模型的一个实例，例如，某连锁宾馆，不同店计费模式相同，但是单价不同，每个店的计费标准就是一个模型实例 BillingModel.Algorithm，某一个时段的计费法则 BillingModel.Fragment，计费段。时序计费时，可能会把一个连续时长按照标准切分成多个时段，逐一计算。时序段包含一个计费法则和一个时间段 TimeBasedRevision，时序的调整项目 WholeTimeRevision，切分前调整 FragmentRevision，基于特定计费段的调整 coodex-billing也提供了一个时序计费模型的参考实现，方便开发者使用，参考实现的约定包括： AbstractAlgorithm 增加了是否允许不连续时段的属性，例如，一个计费段是[11:00 - 23:00]，消费的时段为[12:00 - 20:00]，使用一张[14:00 - 15:00]抵扣的优惠卷，那么此计费段内需要计费的时段变成了[12:00 - 14:00]和[15:00 - 20:00]，该属性为真时，计费时长为7小时，否则，会分两次计算，可根据计费标准指定 AbstractBillingModel，计费模型的参考实现，开发者只需要指定具体的TimeBasedChargeable记忆模型的编码即可 ModelProfileFactory，模型参数仓库，开发者自行实现，例如，不同模型的变量结构是不一样的，可以为每个模型见一个数据库表，然后根据id来提取数据 FragmentSlicer，计费段切片器，coodex-billing提供了3钟开箱即用的切片器，也可以通过SlicerProfile/SlicerFactory自行扩展 按自然日切片(FxiedDateSlicerProfile，FxiedDateSlicerFactory)，可以指定从每天的何时开始进行切片，默认从0点开始 固定小时数切片(FixedHoursSlicerProfile, FixedHoursSlicerFactory)，可以指定多少小时一段，不得小于1 时段切片(FragmentSlicerProfile，FragmentSlicerFactory)，可以指定从何时到何时进行切片，例如，00:00 - 04:00。当开始时间描述大于结束时间描述时，说明结束时间为次日，例如，20:00 - 08:00，表示当日20:00到次日的08:00 计费规则体系，使用计费参数(AlgorithmProfile)及计费实例工厂(AlgorithmFactory)自行实现 实践示例 我们以一个按时计费的KTV为案例实践一遍，由浅入深，一点点扩展，最终达到月月鸟在某KTV中包消费一段时长，并额外消费了XX，使用多优惠券、VIP、包时段来出结算单的场景 话说，月月鸟童鞋忙完了一个项目，拿到一笔丰厚的奖金，准备犒劳犒劳自己，在大街上走着走着就走进了之前常来的一家KTV，进门以后就看见收费标准如下： 时间段 大包 中包 小包 02:00 - 08:00 228元/小时 128元/小时 88元/小时 08:00 - 18:00 118元/小时 68元/小时 48元/小时 18:00 - 次日02:00 448元/小时 248元/小时 168元/小时 * 加入VIP/VVIP享受更多优惠，详情请咨询前台 月月鸟童鞋心想，上次的小包腾挪不开，这次有钱了，来个中包吧。 三天以后，月月鸟满意的来到前台结算，OK，我们开始。 计费对象 package org.coodex.billing.demo; import org.coodex.billing.Revision; import org.coodex.billing.timebased.Period; import org.coodex.billing.timebased.TimeBasedChargeable; import org.coodex.util.Common; import java.text.ParseException; import java.util.List; import static org.coodex.billing.demo.Constants.MODEL_01; public class KTVConsumption implements TimeBasedChargeable { public enum Room{ LARGE, MIDDLE, SMALL } public static void main(String[] args) { KTVConsumption ktvConsumption = new KTVConsumption(); Bill bill = BillCalculator.calc(ktvConsumption); StringBuilder builder = new StringBuilder(\"`月月鸟`在`KTV`的消费总金额 \") .append(bill.getAmount()).append(\" 元。明细如下：\"); for (Bill.Detail detail : bill.getDetails()) { builder.append(\"\\n \"); if (detail instanceof TimeBasedDetail) { TimeBasedDetail timeBasedDetail = (TimeBasedDetail) detail; builder.append(\"[\") .append(Common.calendarToStr(timeBasedDetail.getPeriod().getStart())) .append(\" - \") .append(Common.calendarToStr(timeBasedDetail.getPeriod().getEnd())) .append(\"]\"); } builder.append(detail.item()).append(\" 金额: \").append(detail.getAmount()).append(\"元\"); if (detail.usedRevision() != null) { builder.append(\" \").append(detail.usedRevision().getName()); } } System.out.println(builder.toString()); } @Override public Period getPeriod() { try { return Period.BUILDER.create( Common.strToCalendar(\"2019-09-18 16:47:30\", Common.DEFAULT_DATETIME_FORMAT), Common.strToCalendar(\"2019-09-21 20:50:00\", Common.DEFAULT_DATETIME_FORMAT) ); } catch (ParseException e) { throw new RuntimeException(e.getLocalizedMessage(), e); } } @Override public String getModel() { return MODEL_01; } @Override public String getModelParam() { return MODEL_01 + \"_01\"; } @Override public void setModelParam(String modelParam) { // 多条规则时使用 } @Override public void setModel(String model) { // 多条规则时使用 } @Override public void setPeriod(Period period) { // 多条规则时使用 } @Override public String getRefId() { return \"月月鸟\"; } @Override public List getRevisions() { // 暂不使用优惠 return null; } public Room getRoomType(){ return Room.MIDDLE; } } 说明一下，此处我们没有通过外部设置业务对象，实际业务场景中，需要由业务逻辑根据数据构建可计费对象 KTVConsumption领域下的账单计算器 package org.coodex.billing.demo; import org.coodex.billing.timebased.AbstractTimeBasedCalculator; import java.util.concurrent.TimeUnit; public class KTVBillCalculator extends AbstractTimeBasedCalculator { @Override protected TimeUnit getTimeUnit() { return TimeUnit.MINUTES; } @Override protected KTVConsumption copyChargeable(KTVConsumption chargeable, List revisions) { return chargeable; } @Override public boolean accept(KTVConsumption param) { return param != null; } } 放入到SPI:META-INF/services/org.coodex.billing.Calculator org.coodex.billing.demo.KTVBillCalculator MODEL_01计费模型 package org.coodex.billing.demo; import org.coodex.billing.timebased.reference.AbstractBillingModel; import static org.coodex.billing.demo.Constants.MODEL_01; public class Model01 extends AbstractBillingModel { @Override protected String getModelCode() { return MODEL_01; } } 放入到SPI:META-INF/services/org.coodex.billing.timebased.BillingModel org.coodex.billing.demo.Model01 模型参数工厂 package org.coodex.billing.demo; import org.coodex.billing.timebased.reference.AlgorithmProfile; import org.coodex.billing.timebased.reference.FragmentProfile; import org.coodex.billing.timebased.reference.ModelProfile; import org.coodex.billing.timebased.reference.ModelProfileFactory; import java.util.Arrays; import java.util.List; import static org.coodex.billing.demo.Constants.MODEL_01; public class Model01ProfileFactory implements ModelProfileFactory { @Override public ModelProfile build(String s) { return new ModelProfile() { @Override public AlgorithmProfile getWholeTimeAlgorithmProfile() { return null; } @Override public List getFragmentProfiles() { // 一会增加 return Arrays.asList(); } }; } @Override public boolean accept(String param) { return param != null && param.equals(MODEL_01); } } 放入到SPI:META-INF/services/org.coodex.billing.timebased.reference.ModelProfileFactory org.coodex.billing.demo.Model01ProfileFactory 好了，截止到目前位置，针对KTV消费领域的模型框架搭好了，跑一下 `月月鸟`在`KTV`的消费总金额 0 元。明细如下： [2019-09-18 16:47:30 - 2019-09-21 20:50:00]no algorithm found. 金额: 0元 下面开始完成月月鸟看到的计费规则 计费法则 计费法则的变量 package org.coodex.billing.demo; import org.coodex.billing.timebased.reference.AlgorithmProfile; public class PerHourAlgorithmProfile implements AlgorithmProfile { private int priceLargeRoom; private int priceMiddleRoom; private int priceSmallRoom; public PerHourAlgorithmProfile(int priceLargeRoom, int priceMiddleRoom, int priceSmallRoom) { this.priceLargeRoom = priceLargeRoom; this.priceMiddleRoom = priceMiddleRoom; this.priceSmallRoom = priceSmallRoom; } public int getPriceLargeRoom() { return priceLargeRoom; } public int getPriceMiddleRoom() { return priceMiddleRoom; } public int getPriceSmallRoom() { return priceSmallRoom; } } 计费法则工厂 package org.coodex.billing.demo; import org.coodex.billing.Bill; import org.coodex.billing.timebased.AbstractTimeBasedCalculator; import org.coodex.billing.timebased.BillingModel; import org.coodex.billing.timebased.Period; import org.coodex.billing.timebased.reference.AbstractAlgorithm; import org.coodex.billing.timebased.reference.AlgorithmFactory; public class PerHourAlgorithmFactory implements AlgorithmFactory { @Override public BillingModel.Algorithm build(final PerHourAlgorithmProfile perHourAlgorithmProfile) { return new AbstractAlgorithm() { private int getPricePerHour(KTVConsumption ktvConsumption) { switch (ktvConsumption.getRoomType()) { case LARGE: return perHourAlgorithmProfile.getPriceLargeRoom(); case MIDDLE: return perHourAlgorithmProfile.getPriceMiddleRoom(); default: return perHourAlgorithmProfile.getPriceSmallRoom(); } } private long getPrice(KTVConsumption ktvConsumption, long duration) { int remainder = (int) (duration % 60); int quotient = (int) (duration / 60); int pricePerHour = getPricePerHour(ktvConsumption); return quotient * pricePerHour + (remainder > 0 ? pricePerHour : 0); } private String getItemName(KTVConsumption ktvConsumption) { switch (ktvConsumption.getRoomType()) { case LARGE: return \"大包包间费\"; case MIDDLE: return \"中包包间费\"; default: return \"小包包间费\"; } } @Override protected Bill.Detail calc(Period period, long duration, KTVConsumption chargeable) { return new AbstractTimeBasedCalculator.TimeBasedDetailImpl( period, getPrice(chargeable, duration), getItemName(chargeable) + \" 消费 \" + duration + \" 分钟\" ); } }; } @Override public boolean accept(PerHourAlgorithmProfile param) { return param != null; } } 放到SPI:META-INF/services/org.coodex.billing.timebased.reference.AlgorithmFactory org.coodex.billing.demo.PerHourAlgorithmFactory ok，跑一把看看 `月月鸟`在`KTV`的消费总金额 11176 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:00:00]中包包间费 消费 72 分钟 金额: 136元 [2019-09-18 18:00:00 - 2019-09-19 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 20:50:00]中包包间费 消费 170 分钟 金额: 744元 月月鸟一看，嚯，1万多，完了完了完了，回家没法交待了，还好，我有张6折卡，还有上次消费返还的2小时的抵扣时长和1500的代金券，再算算。 优惠 可计费对象里，增加调整项： @Override public List getRevisions() { return Arrays.asList( new DurationRevision(\"2小时抵扣\", 120), new TimeBasedOffAdjustment(0.4f, \"6折房间费\"), new AmountAdjustment(1500, \"1500元代金券\") ); } 好的，再看看 `月月鸟`在`KTV`的消费总金额 5124 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:47:30]2小时抵扣 金额: 0元 2小时抵扣 [2019-09-18 18:47:30 - 2019-09-19 02:00:00]中包包间费 消费 432 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 20:50:00]中包包间费 消费 170 分钟 金额: 744元 6折房间费 金额: -4416元 6折房间费 1500元代金券 金额: -1500元 1500元代金券 月月鸟说： 你把时长从后面减掉我看看，好像从后面减合适点 店员：成吧，看在你是熟客，一般人我可真不这样 @Override public List getRevisions() { return Arrays.asList( new DurationRevision(\"5小时抵扣\", 120， false), new TimeBasedOffAdjustment(0.4f, \"6折房间费\"), new AmountAdjustment(1500, \"1500元代金券\") ); } `月月鸟`在`KTV`的消费总金额 4908 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:00:00]中包包间费 消费 72 分钟 金额: 136元 [2019-09-18 18:00:00 - 2019-09-19 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 18:50:00]中包包间费 消费 50 分钟 金额: 248元 [2019-09-21 18:50:00 - 2019-09-21 20:50:00]2小时抵扣 金额: 0元 2小时抵扣 6折房间费 金额: -4272元 6折房间费 1500元代金券 金额: -1500元 1500元代金券 月月鸟：果然，从后面算划算，来吧，结账吧 店员：稍等，查房马上给结果 额外消费 店员：不好意思，您还消费了方便面10盒，XXX七个。服务员的消费您是单独结还是一起结？ public List getRevisions() { return Arrays.asList( new DurationRevision(\"2小时抵扣\", 120), new TimeBasedOffAdjustment(0.4f, \"6折房间费\"), new AmountAdjustment(1500, \"1500元代金券\"), new ConsumerGoods(10,10,\"方便面\"), new ConsumerGoods(15,7,\"XXX\"), new ConsumerGoods(300,5,\"XMA\"), new ConsumerGoods(400,2,\"XMB\") ); } `月月鸟`在`KTV`的消费总金额 7629 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:47:30]2小时抵扣 金额: 0元 2小时抵扣 [2019-09-18 18:47:30 - 2019-09-19 02:00:00]中包包间费 消费 432 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 20:50:00]中包包间费 消费 170 分钟 金额: 744元 6折房间费 金额: -4416元 6折房间费 1500元代金券 金额: -1500元 1500元代金券 方便面[10 x 10.0] 金额: 100元 方便面[10 x 10.0] XXX[15 x 7.0] 金额: 105元 XXX[15 x 7.0] XMA[300 x 5.0] 金额: 1500元 XMA[300 x 5.0] XMB[400 x 2.0] 金额: 800元 XMB[400 x 2.0] 月月鸟：服务员结过了、结过了，一次一结的 店员：好的 @Override public List getRevisions() { return Arrays.asList( new DurationRevision(\"2小时抵扣\", 120), new TimeBasedOffAdjustment(0.4f, \"6折房间费\"), new AmountAdjustment(1500, \"1500元代金券\"), new ConsumerGoods(10,10,\"方便面\"), new ConsumerGoods(15,7,\"XXX\") ); } `月月鸟`在`KTV`的消费总金额 5329 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:47:30]2小时抵扣 金额: 0元 2小时抵扣 [2019-09-18 18:47:30 - 2019-09-19 02:00:00]中包包间费 消费 432 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 20:50:00]中包包间费 消费 170 分钟 金额: 744元 6折房间费 金额: -4416元 6折房间费 1500元代金券 金额: -1500元 1500元代金券 方便面[10 x 10.0] 金额: 100元 方便面[10 x 10.0] XXX[15 x 7.0] 金额: 105元 XXX[15 x 7.0] 抹零 月月鸟：你把零头抹了吧 店员：好的 public List getRevisions() { return Arrays.asList( new DurationRevision(\"2小时抵扣\", 120), new TimeBasedOffAdjustment(0.4f, \"6折房间费\"), new AmountAdjustment(1500, \"1500元代金券\"), new ConsumerGoods(10,10,\"方便面\"), new ConsumerGoods(15,7,\"XXX\"), new ZeroRemainderAdjustment(\"抹零\",100) ); } `月月鸟`在`KTV`的消费总金额 5300 元。明细如下： [2019-09-18 16:47:30 - 2019-09-18 18:47:30]2小时抵扣 金额: 0元 2小时抵扣 [2019-09-18 18:47:30 - 2019-09-19 02:00:00]中包包间费 消费 432 分钟 金额: 1984元 [2019-09-19 02:00:00 - 2019-09-19 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-19 08:00:00 - 2019-09-19 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-19 18:00:00 - 2019-09-20 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-20 02:00:00 - 2019-09-20 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-20 08:00:00 - 2019-09-20 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-20 18:00:00 - 2019-09-21 02:00:00]中包包间费 消费 480 分钟 金额: 1984元 [2019-09-21 02:00:00 - 2019-09-21 08:00:00]中包包间费 消费 360 分钟 金额: 768元 [2019-09-21 08:00:00 - 2019-09-21 18:00:00]中包包间费 消费 600 分钟 金额: 680元 [2019-09-21 18:00:00 - 2019-09-21 20:50:00]中包包间费 消费 170 分钟 金额: 744元 6折房间费 金额: -4416元 6折房间费 1500元代金券 金额: -1500元 1500元代金券 方便面[10 x 10.0] 金额: 100元 方便面[10 x 10.0] XXX[15 x 7.0] 金额: 105元 XXX[15 x 7.0] 抹零 金额: -29元 抹零 店员：一共5300，老板是现金、刷卡还是电子支付？ © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 14:17:26 "},"coodex-junit-enhance/":{"url":"coodex-junit-enhance/","title":"junit强化","keywords":"","body":"junit 单元调试场景工具 一个相对复杂的系统，需要多个测试场景的用例。如果你也碰到了以下问题，可以试一下coodex-junit-enhance 需要为每一个测试场景的用例单独输出日志，可是数量是不定的，传统做法也有，每个用例定义一个Logger，然后logging工具配置输出，麻烦 需要模拟时间流逝，天上人间虽然也能做到，但是不管几倍流逝速率，都还是慢，比如说，模拟一个3小时的活动，活动结束后推送消息，哪怕倍率是100倍，依然需要等待1.8分钟，要是一年呢？我们希望越快越好 我们来看一下coodex-junit-enhance怎么解决上面的问题。话不多说，开搞。 测试作用域增加coodex-junit-enhance的依赖 org.coodex coodex-junit-enhance ${coodex.libraries.version} test org.apache.logging.log4j log4j-slf4j-impl ${coodex.libraries.version} test 把org.coodex.junit.enhance.Log4j2LoggerProvider放到SPI中，本案例使用java默认的SPI org.coodex.junit.enhance.LoggerProvider org.coodex.junit.enhance.Log4j2LoggerProvider 测试用例代码 package test.org.coodex.demo; import org.coodex.junit.enhance.Context; import org.coodex.junit.enhance.CoodexEnhanceTestRule; import org.coodex.util.Common; import org.junit.Rule; import org.junit.Test; import static org.coodex.junit.enhance.TestUtils.TIME; import static org.coodex.junit.enhance.TestUtils.logger; public class JUnitEnhanceExample { // 使用coodex enhance rule @Rule public CoodexEnhanceTestRule testRule = new CoodexEnhanceTestRule(); @Test @Context(name = \"如不指定会用方法名\") public void test1() { logger.info(\"now {}\", Common.now()); /** * 时间跳转到明年元旦，TestUtil.TIME提供了丰富的接口 * * @see org.coodex.junit.enhance.TestUtils.Time */ TIME.nextYear(); logger.info(\"now {}\", Common.now()); } @Test public void test2() { logger.info(\"第二个测试场景\"); } } 回到前面的问题 我们没有做任何的log4j2的配置，运行完以后，logs目录下会出现两个案例的日志文件(参见下图)，效果就是，你只管加测试用例就行，不需要管logging配置 时间流逝，9个ms跑了10个月，支持用通过ExecutorsHelper创建的线程池，TestUtils也有异步执行的接口，支持天上人间，也就是说，你在业务代码中，使用Clock.now()，在测试环境和生产环境都适用 01:47:16.123 [main] INFO 如不指定会用方法名 - now 2020-03-02 01:47:16 01:47:16.132 [main] INFO 如不指定会用方法名 - now 2021-01-01 00:00:00 同样的，这部分也有扩展点，可以方便的注入测试用例上下文 © coodex.org 2014-2020 all right reserved，powered by GitbookFile Modify: 2020-05-11 14:16:40 "}}